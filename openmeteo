#!/usr/bin/env python3

import argparse, itertools, re, sys, requests, datetime, pytz, unicodedata
from dataclasses import dataclass
from typing import List, Tuple, Dict

@dataclass
class Weather:
    temp: float
    precip: float
    code: int

@dataclass
class Coord:
    latitude: float
    longitude: float

    def link(self):
        return f"https://www.google.com/maps/place/{self.latitude},{self.longitude}"

@dataclass
class Forecast:
    times: List[datetime.datetime]
    by_model: Dict[str, List[Weather]]
    timezone: datetime.tzinfo
    location: Tuple[float, float]


def download_forecast(latitude, longitude, models):
    params = {
        'latitude': latitude,
        'longitude': longitude,
        'hourly': 'temperature_2m,precipitation,weather_code',
        'models': ','.join(models),
        'forecast_days': 16,
        'timezone': 'auto',
    }
    response = requests.get('https://api.open-meteo.com/v1/forecast', params=params)
    response.raise_for_status()
    data = response.json()

    propname = lambda prop, model: prop if len(models) == 1 else f'{prop}_{model}'
    for model in models:
        assert data['hourly_units'][propname('temperature_2m', model)] == '째C'
        assert data['hourly_units'][propname('precipitation', model)] == 'mm'
        assert data['hourly_units'][propname('weather_code', model)] == 'wmo code'
        assert len(data['hourly'][propname('temperature_2m', model)]) == len(data['hourly']['time'])
        assert len(data['hourly'][propname('precipitation', model)]) == len(data['hourly']['time'])
        assert len(data['hourly'][propname('weather_code', model)]) == len(data['hourly']['time'])

    timezone = pytz.timezone(data['timezone'])
    times = [timezone.localize(datetime.datetime.fromisoformat(time)) for time in data['hourly']['time']]
    location = Coord(data['latitude'], data['longitude'])

    by_model = {}
    for model in models:
        forecast = [Weather(temp, precip, code)
                    for temp, precip, code in zip(data['hourly'][propname('temperature_2m', model)],
                                                  data['hourly'][propname('precipitation', model)],
                                                  data['hourly'][propname('weather_code', model)])]
        by_model[model] = forecast

    return Forecast(times, by_model, timezone, location)


@dataclass
class Current:
    weather: Weather
    time: datetime.datetime
    location: Coord


def download_current(latitude, longitude):
    params = {
        'latitude': latitude,
        'longitude': longitude,
        'current': 'temperature_2m,precipitation,weather_code',
        'timezone': 'auto',
    }
    response = requests.get('https://api.open-meteo.com/v1/forecast', params=params)
    response.raise_for_status()
    data = response.json()

    assert data['current_units']['temperature_2m'] == '째C'
    assert data['current_units']['precipitation'] == 'mm'
    assert data['current_units']['weather_code'] == 'wmo code'

    timezone = pytz.timezone(data['timezone'])
    time = timezone.localize(datetime.datetime.fromisoformat(data['current']['time']))
    location = Coord(data['latitude'], data['longitude'])
    weather = Weather(data['current']['temperature_2m'], data['current']['precipitation'],
                      data['current']['weather_code'])
    return Current(weather, time, location)


# assert dedup(["foo", "foo", "foo", "bar", "bar", "baz"]) == ["foo", "", "", "bar", "", "baz"]
def dedup(iterable):
    return ["" if i > 0 else k for k, g in itertools.groupby(iterable) for i in range(len(list(g)))]

def extract_forecast_table(times, by_model, time_range):
    start_time, end_time = time_range
    in_range = lambda dt: start_time <= dt < end_time

    headers = ["Date", "Hour"]
    columns = []
    columns.append(dedup(dt.date() for dt in times if in_range(dt)))
    columns.append([dt.strftime('%Hh') for dt in times if in_range(dt)])

    groups = [(None, 2)]  # first 2 columns have no group header
    num_rows = sum(1 for dt in times if in_range(dt))
    for model, data in by_model.items():
        temps, precips, codes = [], [], []
        for time, weather in zip(times, data):
            if not in_range(time):
                continue
            temps.append(weather.temp)
            codes.append(weather.code)
            if weather.precip == 0:
                precips.append('')
            elif weather.precip is None:
                precips.append('-')
            else:
                precips.append(weather.precip)
        # Trailing empty column absorbs excess width when model name is wide,
        # keeping Rain column tight (it's right-justified, so padding would go left)
        headers.extend(["", "Temp", "Rain", ""])
        columns.append([weather_symbol(c) for c in codes])
        columns.append([f'{t:.0f}째' if t is not None else '-' for t in temps])
        columns.append(precips)
        columns.append([''] * num_rows)
        groups.append((model, 4))

    return headers, columns, groups

WMO_SYMBOLS = {
    0: '\N{BLACK SUN WITH RAYS}',                       # Clear sky
    1: '\N{WHITE SUN WITH SMALL CLOUD}',                # Mainly clear
    2: '\N{SUN BEHIND CLOUD}',                          # Partly cloudy
    3: '\N{CLOUD}',                                     # Overcast
    45: '\N{FOG}',                                      # Fog
    48: '\N{FOG}',                                      # Depositing rime fog
    51: '\N{CLOUD WITH RAIN}',                          # Drizzle light
    53: '\N{CLOUD WITH RAIN}',                          # Drizzle moderate
    55: '\N{CLOUD WITH RAIN}',                          # Drizzle dense
    56: '\N{CLOUD WITH RAIN}',                          # Freezing drizzle light
    57: '\N{CLOUD WITH RAIN}',                          # Freezing drizzle dense
    61: '\N{CLOUD WITH RAIN}',                          # Rain slight
    63: '\N{CLOUD WITH RAIN}',                          # Rain moderate
    65: '\N{CLOUD WITH RAIN}',                          # Rain heavy
    66: '\N{CLOUD WITH RAIN}',                          # Freezing rain light
    67: '\N{CLOUD WITH RAIN}',                          # Freezing rain heavy
    71: '\N{SNOWFLAKE}',                                # Snow slight
    73: '\N{SNOWFLAKE}',                                # Snow moderate
    75: '\N{SNOWFLAKE}',                                # Snow heavy
    77: '\N{CLOUD WITH SNOW}',                          # Snow grains
    80: '\N{WHITE SUN BEHIND CLOUD WITH RAIN}',         # Rain showers slight
    81: '\N{WHITE SUN BEHIND CLOUD WITH RAIN}',         # Rain showers moderate
    82: '\N{WHITE SUN BEHIND CLOUD WITH RAIN}',         # Rain showers violent
    85: '\N{CLOUD WITH SNOW}',                          # Snow showers slight
    86: '\N{CLOUD WITH SNOW}',                          # Snow showers heavy
    95: '\N{THUNDER CLOUD AND RAIN}',                   # Thunderstorm
    96: '\N{THUNDER CLOUD AND RAIN}',                   # Thunderstorm with slight hail
    99: '\N{THUNDER CLOUD AND RAIN}',                   # Thunderstorm with heavy hail
}

def _grapheme_width(char):
    eaw = unicodedata.east_asian_width(char)
    return 2 if eaw in ('F', 'W') else 1

def weather_symbol(code):
    # Add a space after narrow emoji so all symbols have width 2, allowing alignment with
    # wide emoji. This must be done here rather than in the display code because the space
    # must always follow the emoji, and the display wants to add padding before it.
    if code is None:
        return '-'
    sym = WMO_SYMBOLS.get(code, '?')
    return sym + ' ' if _grapheme_width(sym) == 1 else sym

def display_width(s):
    return sum(_grapheme_width(ch) for ch in str(s))

def _ljust(s, width):
    return str(s) + ' ' * (width - display_width(s))

def _rjust(s, width):
    return ' ' * (width - display_width(s)) + str(s)

def _fmt(o):
    return '-' if o is None else str(o)

def pretty_print(headers, *data, groups=None):
    widths = [max(display_width(h), max((display_width(_fmt(v)) for v in col), default=0))
              for h, col in zip(headers, data)]

    # When groups are provided, widen columns so group names fit, then print group header row
    if groups:
        col = 0
        for name, count in groups:
            if name is not None:
                span_width = sum(widths[col:col+count]) + count - 1  # columns + spaces between
                name_width = display_width(name)
                if name_width > span_width:
                    widths[col + count - 1] += name_width - span_width
            col += count
        # Print group header row
        parts = []
        col = 0
        for name, count in groups:
            span_width = sum(widths[col:col+count]) + count - 1
            parts.append(_ljust(name or '', span_width))
            col += count
        print(" ".join(parts))

    # Print column headers
    print(" ".join(_ljust(h, w) for h, w in zip(headers, widths)))

    # Print data rows
    for data_row in zip(*data):
        print(" ".join(_rjust(_fmt(n), width) for width, n in zip(widths, data_row)))

def resolve_location(s):
    if mtch := re.fullmatch(r"( -? \d+ (?:\. \d+)?),(-? \d+ (?:\. \d+)?)", s, re.X):
        latitude, longitude = float(mtch.group(1)), float(mtch.group(2))
        if not (-90 <= latitude <= 90) or not (-180 <= longitude <= 180):
            raise ValueError("Latitude must be between -90 and 90, longitude between -180 and 180")
        return s, latitude, longitude
    response = requests.get('https://nominatim.openstreetmap.org/search.php',
                            params={'q': s, 'format': 'jsonv2'},
                            headers={'User-Agent': 'curl/8.9.1'})
    response.raise_for_status()
    locations = response.json()
    if not locations:
        raise ValueError(f"unknown location {s}")
    location = locations[0]
    return location['display_name'], float(location['lat']), float(location['lon'])

def parse_date(s):
    s = s.lower()
    if s in ("today", "tomorrow") or s in DAYS_OF_THE_WEEK:
        return s
    return datetime.datetime.strptime(s, '%Y-%m-%d').date()

def parse_date_range(s):
    if (pos := s.find('..')) != -1:
        a = parse_date(s[:pos])
        b = parse_date(s[pos +2:])
        return a, b
    else:
        d = parse_date(s)
        return d, d

DAYS_OF_THE_WEEK = {
    'mon': 0, 'tue': 1, 'wed': 2, 'thu': 3, 'fri': 4, 'sat': 5, 'sun': 6,
    'monday': 0, 'tuesday': 1, 'wednesday': 2, 'thursday': 3, 'friday': 4, 'saturday': 5, 'sunday': 6,
}

def resolve_date(dt, today, weekday_start_at):
    if dt == "today":
        return today
    if dt == "tomorrow":
        return today + datetime.timedelta(1)
    if (wanted_weekday := DAYS_OF_THE_WEEK.get(dt)) is not None:
        dt = weekday_start_at
        while dt.weekday() != wanted_weekday:
            dt += datetime.timedelta(1)
    return dt

def resolve_time_range(start_date, end_date, timezone):
    now = datetime.datetime.now(timezone)
    if now.hour == 23:
        if start_date == "today":
            start_date = "tomorrow"
        if end_date == "today":
            end_date = "tomorrow"
    start_date = resolve_date(start_date, now.date(), now.date())
    end_date = resolve_date(end_date, now.date(), start_date)
    start_time = timezone.localize(datetime.datetime(start_date.year, start_date.month, start_date.day, 0, 0, 0))
    start_time = max(start_time, now)
    end_date += datetime.timedelta(1)
    end_time = timezone.localize(datetime.datetime(end_date.year, end_date.month, end_date.day, 0, 0, 0))
    return start_time, end_time

def do_forecast(args):
    try:
        location_name, latitude, longitude = resolve_location(args.location)
    except ValueError as e:
        print(f"{sys.argv[0]}: {e}", file=sys.stderr)
        sys.exit(1)

    try:
        start_date, end_date = parse_date_range(args.dates)
    except ValueError as e:
        print(f"{sys.argv[0]}: dates must be YYYY-MM-DD, YYYY-MM-DD..YYYY-MM-DD, 'today' or 'tomorrow'", file=sys.stderr)
        sys.exit(1)

    print(f"Forecast for {location_name}")

    forecast = download_forecast(latitude, longitude, args.models)
    time_range = resolve_time_range(start_date, end_date, forecast.timezone)

    if args.verbose:
        print(f"Grid-cell location: {forecast.location.link()}")
        print(f"Timezone: {forecast.timezone}")
        print(f"Interval: [{time_range[0]}, {time_range[1]})")

    headers, columns, groups = extract_forecast_table(forecast.times, forecast.by_model, time_range)
    pretty_print(headers, *columns, groups=groups)

def do_current(args):
    try:
        location_name, latitude, longitude = resolve_location(args.location)
    except ValueError as e:
        print(f"{sys.argv[0]}: {e}", file=sys.stderr)
        sys.exit(1)
    print(f"Current weather for {location_name}")
    current = download_current(latitude, longitude)
    if args.verbose:
        print(f"Grid-cell location: {current.location.link()}")
    pretty_print(["Time", "", "Temp", "Rain"],
                 [current.time.strftime("%Y-%m-%d %H:%M")],
                 [weather_symbol(current.weather.code)],
                 [f'{current.weather.temp:.0f}째'],
                 ['' if current.weather.precip==0
                  else '-' if current.weather.precip is None
                  else current.weather.precip])

def main():
    parser = argparse.ArgumentParser(description="Fetch weather data from OpenMeteo.")
    subparsers = parser.add_subparsers(dest='command', help='Available commands')

    forecast_parser = subparsers.add_parser('forecast', help='Fetch weather forecast for a given location and dates')
    forecast_parser.add_argument('location', help="Location name or lat,long pair")
    forecast_parser.add_argument('dates', nargs='?', default='today',
                                 help="YYYY-MM-DD, 'today', 'tomorrow', or weekday, or date1..date2")
    forecast_parser.add_argument(
        '--models', default='gfs_graphcast025,ecmwf_ifs025',
        type=lambda s: s.split(','),
        help="Comma-separated list of forecast models - e.g. gfs_graphcast025,icon_eu,ecmwf_ifs025")
    forecast_parser.add_argument('-v', '--verbose', action='store_true')

    current_parser = subparsers.add_parser('current', help='Fetch current weather for a given location')
    current_parser.add_argument('location', help="Location name or lat,long pair")
    current_parser.add_argument('-v', '--verbose', action='store_true')

    args = parser.parse_args()

    # Test which command was invoked
    if args.command == 'forecast':
        do_forecast(args)
    elif args.command == 'current':
        do_current(args)
    else:
        parser.print_help()

if __name__ == "__main__":
    main()
